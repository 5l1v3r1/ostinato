<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>

<title>AbstractProtocol Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />



</head>
<body>
<div id="top"><!-- do not remove this div! -->


<!-- Generated by Doxygen 1.7.5.1 -->
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<div class="title">AbstractProtocol Class Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="AbstractProtocol" -->
<p><a class="el" href="class_abstract_protocol.html" title="AbstractProtocol is the base abstract class which provides the interface for all protocols.">AbstractProtocol</a> is the base abstract class which provides the interface for all protocols.  
 <a href="class_abstract_protocol.html#details">More...</a></p>

<p><a href="class_abstract_protocol-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_protocol.html#a71a018a1a39da3fd0b22f348e21c85e8">FieldFlag</a> { <a class="el" href="class_abstract_protocol.html#a71a018a1a39da3fd0b22f348e21c85e8a975bb1cfe826bcf6044b7432f8b4dee4">FrameField</a> =  0x1, 
<a class="el" href="class_abstract_protocol.html#a71a018a1a39da3fd0b22f348e21c85e8a4674267e0b1ca900b107823a094c44f2">MetaField</a> =  0x2, 
<a class="el" href="class_abstract_protocol.html#a71a018a1a39da3fd0b22f348e21c85e8ac5407d0629943e055651b900df2b8cfa">CksumField</a> =  0x4
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Properties of a field, can be OR'd.  <a href="class_abstract_protocol.html#a71a018a1a39da3fd0b22f348e21c85e8">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_protocol.html#a264223e35af983ba7016700b17f24b2c">FieldAttrib</a> { <br/>
&#160;&#160;<a class="el" href="class_abstract_protocol.html#a264223e35af983ba7016700b17f24b2ca6a6eabda81c9937845258bd6a87197af">FieldName</a>, 
<a class="el" href="class_abstract_protocol.html#a264223e35af983ba7016700b17f24b2ca6f6cbe2c8b4bb7ba90f77bb71ab148df">FieldValue</a>, 
<a class="el" href="class_abstract_protocol.html#a264223e35af983ba7016700b17f24b2ca39c3a7bfe08b218a6dd0b0c93752cf57">FieldTextValue</a>, 
<a class="el" href="class_abstract_protocol.html#a264223e35af983ba7016700b17f24b2cabb3fc3111e7d887281728ccd95c0e876">FieldFrameValue</a>, 
<br/>
&#160;&#160;<a class="el" href="class_abstract_protocol.html#a264223e35af983ba7016700b17f24b2cabf037461e1abed7603d311f701a560d8">FieldBitSize</a>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Various attributes of a field.  <a href="class_abstract_protocol.html#a264223e35af983ba7016700b17f24b2c">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_protocol.html#a94af7be261834da225cdda75223a600f">ProtocolIdType</a> { <br/>
&#160;&#160;<a class="el" href="class_abstract_protocol.html#a94af7be261834da225cdda75223a600fa7caf04230689c991aea6ea98dd6cb44f">ProtocolIdNone</a>, 
<a class="el" href="class_abstract_protocol.html#a94af7be261834da225cdda75223a600fa018f343eea81889b34ce37be982a0949">ProtocolIdLlc</a>, 
<a class="el" href="class_abstract_protocol.html#a94af7be261834da225cdda75223a600fab4be19b14834dbc2106d2f69daad8156">ProtocolIdEth</a>, 
<a class="el" href="class_abstract_protocol.html#a94af7be261834da225cdda75223a600fac232e06fa03ade8b73b6f805fbf4e594">ProtocolIdIp</a>, 
<br/>
&#160;&#160;<a class="el" href="class_abstract_protocol.html#a94af7be261834da225cdda75223a600fa6ccc40767925f33be3c4ba94503d4819">ProtocolIdTcpUdp</a>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported Protocol Id types.  <a href="class_abstract_protocol.html#a94af7be261834da225cdda75223a600f">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_protocol.html#a54c7dc4c12d9fc9032641166551f2b65">CksumType</a> { <a class="el" href="class_abstract_protocol.html#a54c7dc4c12d9fc9032641166551f2b65ae9c2c223559327eda034dc7e3499948f">CksumIp</a>, 
<a class="el" href="class_abstract_protocol.html#a54c7dc4c12d9fc9032641166551f2b65a69e3f4f4e9a5b5ae357380b8e0cb2d4f">CksumIpPseudo</a>, 
<a class="el" href="class_abstract_protocol.html#a54c7dc4c12d9fc9032641166551f2b65a1db5d75b3ca5342d57c78668de8b2c07">CksumTcpUdp</a>, 
<a class="el" href="class_abstract_protocol.html#a54c7dc4c12d9fc9032641166551f2b65a4d5ab2c30b009fbac93c3b1e4e36f8c9">CksumMax</a>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported checksum types.  <a href="class_abstract_protocol.html#a54c7dc4c12d9fc9032641166551f2b65">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_protocol.html#a3fa9027a98c6e78c97ea2b21d278a1ce">CksumScope</a> { <a class="el" href="class_abstract_protocol.html#a3fa9027a98c6e78c97ea2b21d278a1ceaf73a5e1ed72ff2afbd51aadf636f2c4b">CksumScopeAdjacentProtocol</a>, 
<a class="el" href="class_abstract_protocol.html#a3fa9027a98c6e78c97ea2b21d278a1ceaaa680c3020e9d6ec42e3283cd326d6b2">CksumScopeAllProtocols</a>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Supported checksum scopes.  <a href="class_abstract_protocol.html#a3fa9027a98c6e78c97ea2b21d278a1ce">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_protocol.html#a8ef6adaa06c7fc87b5b029f685030848">AbstractProtocol</a> (StreamBase *stream, <a class="el" href="class_abstract_protocol.html">AbstractProtocol</a> *<a class="el" href="class_abstract_protocol.html#a0461f1cdeb9bb4bc85ad7e26daf0d600">parent</a>=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs an abstract protocol for the given stream and parent.  <a href="#a8ef6adaa06c7fc87b5b029f685030848"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_protocol.html#a7ccbf35c6141e0d6aa136e4100c4d39b">~AbstractProtocol</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the abstract protocol.  <a href="#a7ccbf35c6141e0d6aa136e4100c4d39b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual quint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_protocol.html#a11d85e6249098392eb2c29212613b880">protocolNumber</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the protocol's field number as defined in message 'Protocol', enum 'k' (<a href="file:">file:</a> protocol.proto)  <a href="#a11d85e6249098392eb2c29212613b880"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_protocol.html#a818b999e0fe20710b62e100ecad124f3">commonProtoDataCopyInto</a> (OstProto::Protocol &amp;protocol) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the common data (not specific to individual protocols) in the protocol member protobuf data into the passed in protocol parameter.  <a href="#a818b999e0fe20710b62e100ecad124f3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_protocol.html#aa4654b842f274e0daee280684adef2c1">commonProtoDataCopyFrom</a> (const OstProto::Protocol &amp;protocol)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the common data (not specific to individual protocols) from the passed in param protocol protobuf into the member protobuf data.  <a href="#aa4654b842f274e0daee280684adef2c1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_protocol.html#ad632e0fc6fcd86a0fecefd6fa3cf2724">protoDataCopyInto</a> (OstProto::Protocol &amp;protocol) const =0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy the protocol's protobuf as an extension into the passed in protocol.  <a href="#ad632e0fc6fcd86a0fecefd6fa3cf2724"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_protocol.html#a124e67926605177d7787ae649ba57a99">protoDataCopyFrom</a> (const OstProto::Protocol &amp;protocol)=0</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy and update the protocol's protobuf member data variable from the passed in protocol.  <a href="#a124e67926605177d7787ae649ba57a99"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual QString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_protocol.html#a88bb4dec958836f9ec65f32f797253d1">name</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the full name of the protocol.  <a href="#a88bb4dec958836f9ec65f32f797253d1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual QString&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_protocol.html#add629f97f1e6633fc8ec6b936e06ca77">shortName</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the short name or abbreviation of the protocol.  <a href="#add629f97f1e6633fc8ec6b936e06ca77"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_abstract_protocol.html#a94af7be261834da225cdda75223a600f">ProtocolIdType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_protocol.html#abd1dad7fee4194e4da537f82f1a2a162">protocolIdType</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the protocolIdType for the protocol.  <a href="#abd1dad7fee4194e4da537f82f1a2a162"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual quint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_protocol.html#a09724ee80fa35bad5e00bf8581084bb7">protocolId</a> (<a class="el" href="class_abstract_protocol.html#a94af7be261834da225cdda75223a600f">ProtocolIdType</a> type) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the protocol id of the protocol for the given type.  <a href="#a09724ee80fa35bad5e00bf8581084bb7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">quint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_protocol.html#a8115d60319fe23b71b6d4de46d800bef">payloadProtocolId</a> (<a class="el" href="class_abstract_protocol.html#a94af7be261834da225cdda75223a600f">ProtocolIdType</a> type) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the protocol id of the payload protocol (the protocol that immediately follows the current one)  <a href="#a8115d60319fe23b71b6d4de46d800bef"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_protocol.html#a5c26dc650b8480265ceaa8bfb6f30357">fieldCount</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of fields in the protocol (both Frame fields and Meta fields)  <a href="#a5c26dc650b8480265ceaa8bfb6f30357"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_protocol.html#a1720f5fae0e7c90ba52d0d4cb04c80fe">metaFieldCount</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of meta fields.  <a href="#a1720f5fae0e7c90ba52d0d4cb04c80fe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_protocol.html#acac964c423928703a0da8c21fa6dfe50">frameFieldCount</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of frame fields.  <a href="#acac964c423928703a0da8c21fa6dfe50"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual FieldFlags&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_protocol.html#aa9dea7d27d100f8886f3abcad5220e0b">fieldFlags</a> (int index) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the field flags for the passed in field index.  <a href="#aa9dea7d27d100f8886f3abcad5220e0b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual QVariant&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_protocol.html#a63aa72e9a3d7c666f75a5442a36b894b">fieldData</a> (int index, <a class="el" href="class_abstract_protocol.html#a264223e35af983ba7016700b17f24b2c">FieldAttrib</a> attrib, int streamIndex=0) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the requested field attribute data.  <a href="#a63aa72e9a3d7c666f75a5442a36b894b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_protocol.html#ab0c6da690a523a49134944fb1d56b6ac">setFieldData</a> (int index, const QVariant &amp;value, <a class="el" href="class_abstract_protocol.html#a264223e35af983ba7016700b17f24b2c">FieldAttrib</a> attrib=FieldValue)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the value of a field corresponding to index.  <a href="#ab0c6da690a523a49134944fb1d56b6ac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_protocol.html#a1a7491fe014db3307b7e443fcb23d3f8">fieldFrameBitOffset</a> (int index, int streamIndex=0) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the bit offset where the specified field starts within the <a class="el" href="class_abstract_protocol.html#a71c64ddfb9797d2e567013f3dcf93c73" title="Returns a byte array encoding the protocol (and its fields) which can be inserted into the stream&#39;s f...">protocolFrameValue()</a>  <a href="#a1a7491fe014db3307b7e443fcb23d3f8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_protocol.html#ae91b83c11b74182365a51e8736066aaa">variableFieldCount</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the count of variableFields in the protocol.  <a href="#ae91b83c11b74182365a51e8736066aaa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_protocol.html#a020c049c35328d847606a571455cc298">appendVariableField</a> (const OstProto::VariableField &amp;vf)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Appends a variableField to the protocol.  <a href="#a020c049c35328d847606a571455cc298"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_protocol.html#a47c19d80bfeb03af263fd9b5db3bd56a">removeVariableField</a> (int index)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the variableField from the protocol at the specified index.  <a href="#a47c19d80bfeb03af263fd9b5db3bd56a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const OstProto::VariableField &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_protocol.html#ae38a631ad22df35e3fcb8093d58dc0fa">variableField</a> (int index) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the variableField at the specified index as a constant Reference i.e.  <a href="#ae38a631ad22df35e3fcb8093d58dc0fa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">OstProto::VariableField *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_protocol.html#a8afe28a07915431c59c57769ef037cf3">mutableVariableField</a> (int index)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the variableField at the specified index as a mutable pointer.  <a href="#a8afe28a07915431c59c57769ef037cf3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">QByteArray&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_protocol.html#a71c64ddfb9797d2e567013f3dcf93c73">protocolFrameValue</a> (int streamIndex=0, bool forCksum=false) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a byte array encoding the protocol (and its fields) which can be inserted into the stream's frame.  <a href="#a71c64ddfb9797d2e567013f3dcf93c73"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_protocol.html#a62f842e0d07c382e20d70b78ed39c21c">protocolFrameSize</a> (int streamIndex=0) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the protocol's size in bytes.  <a href="#a62f842e0d07c382e20d70b78ed39c21c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_protocol.html#aff15d2fdc6df8db5bc5b13fbacb57675">protocolFrameOffset</a> (int streamIndex=0) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the byte offset in the packet where the protocol starts.  <a href="#aff15d2fdc6df8db5bc5b13fbacb57675"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_protocol.html#af0826fd6957b30bdc1b0af5e9ac6987d">protocolFramePayloadSize</a> (int streamIndex=0) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the size of the payload in bytes.  <a href="#af0826fd6957b30bdc1b0af5e9ac6987d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_protocol.html#aec6223a44cff630869ae4535c00ae11f">isProtocolFrameValueVariable</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the protocol varies one or more of its fields at run-time, false otherwise.  <a href="#aec6223a44cff630869ae4535c00ae11f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_protocol.html#acf6eeb9f4db0848295b125906c92eea4">isProtocolFrameSizeVariable</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the protocol varies its size at run-time, false otherwise.  <a href="#acf6eeb9f4db0848295b125906c92eea4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_protocol.html#a527b6ca531b3489ef29d47bc4f38f361">protocolFrameVariableCount</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the minimum number of frames required for the protocol to vary its fields.  <a href="#a527b6ca531b3489ef29d47bc4f38f361"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_protocol.html#a507683641d443b62e36998b1bd4d3533">isProtocolFramePayloadValueVariable</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the payload content for a protocol varies at run-time, false otherwise.  <a href="#a507683641d443b62e36998b1bd4d3533"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_protocol.html#adb3d714eae41034500c70663a8792790">isProtocolFramePayloadSizeVariable</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the payload size for a protocol varies at run-time, false otherwise.  <a href="#adb3d714eae41034500c70663a8792790"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_protocol.html#ad3cd83ac4774ef40e90a3db4eea44bcd">protocolFramePayloadVariableCount</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the payload size for a protocol varies at run-time, false otherwise.  <a href="#ad3cd83ac4774ef40e90a3db4eea44bcd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_protocol.html#acb1603f1b707cc28b7fb2ad4642eab01">protocolHasPayload</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the protocol typically contains a payload or other protocols following it e.g.  <a href="#acb1603f1b707cc28b7fb2ad4642eab01"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">virtual quint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_protocol.html#af5f206edd6050e10321756889086cc19">protocolFrameCksum</a> (int streamIndex=0, <a class="el" href="class_abstract_protocol.html#a54c7dc4c12d9fc9032641166551f2b65">CksumType</a> cksumType=CksumIp) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the checksum (of the requested type) of the protocol's contents.  <a href="#af5f206edd6050e10321756889086cc19"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">quint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_protocol.html#ac0f92f797429fa74deb4a451ccd18f01">protocolFrameHeaderCksum</a> (int streamIndex=0, <a class="el" href="class_abstract_protocol.html#a54c7dc4c12d9fc9032641166551f2b65">CksumType</a> cksumType=CksumIp, <a class="el" href="class_abstract_protocol.html#a3fa9027a98c6e78c97ea2b21d278a1ce">CksumScope</a> cksumScope=CksumScopeAdjacentProtocol) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the checksum of the requested type for the protocol's header.  <a href="#ac0f92f797429fa74deb4a451ccd18f01"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">quint32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_protocol.html#aa3294a383d53b9d963d885eb53558d62">protocolFramePayloadCksum</a> (int streamIndex=0, <a class="el" href="class_abstract_protocol.html#a54c7dc4c12d9fc9032641166551f2b65">CksumType</a> cksumType=CksumIp, <a class="el" href="class_abstract_protocol.html#a3fa9027a98c6e78c97ea2b21d278a1ce">CksumScope</a> cksumScope=CksumScopeAllProtocols) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the checksum of the requested type for the protocol's payload.  <a href="#aa3294a383d53b9d963d885eb53558d62"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_abstract_protocol.html">AbstractProtocol</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_protocol.html#a5f4b770b062f0cfd90ec9f93f8d737f8">createInstance</a> (StreamBase *stream, <a class="el" href="class_abstract_protocol.html">AbstractProtocol</a> *<a class="el" href="class_abstract_protocol.html#a0461f1cdeb9bb4bc85ad7e26daf0d600">parent</a>=0)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates and returns a new instance of the class.  <a href="#a5f4b770b062f0cfd90ec9f93f8d737f8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0ae45fa454cc9937443b3660df0ce2bc"></a><!-- doxytag: member="AbstractProtocol::lcm" ref="a0ae45fa454cc9937443b3660df0ce2bc" args="(quint64 u, quint64 v)" -->
static quint64&#160;</td><td class="memItemRight" valign="bottom"><b>lcm</b> (quint64 u, quint64 v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2948e0b838f707fbae705729e938f360"></a><!-- doxytag: member="AbstractProtocol::gcd" ref="a2948e0b838f707fbae705729e938f360" args="(quint64 u, quint64 v)" -->
static quint64&#160;</td><td class="memItemRight" valign="bottom"><b>gcd</b> (quint64 u, quint64 v)</td></tr>
<tr><td colspan="2"><h2><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_protocol.html#ad845fce434d744158360470faf446071">CacheFlag</a> { <b>FieldFrameBitOffsetCache</b> =  0x1
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Caching Control Flags.  <a href="class_abstract_protocol.html#ad845fce434d744158360470faf446071">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">StreamBase *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_protocol.html#a64a39e56273fea09038b4f4e2e9288bb">mpStream</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Stream that this protocol belongs to.  <a href="#a64a39e56273fea09038b4f4e2e9288bb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_abstract_protocol.html">AbstractProtocol</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_protocol.html#a0461f1cdeb9bb4bc85ad7e26daf0d600">parent</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Parent protocol, if any.  <a href="#a0461f1cdeb9bb4bc85ad7e26daf0d600"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_abstract_protocol.html">AbstractProtocol</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_protocol.html#a94cb5005a93c5318a99234f36c9259e5">prev</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Protocol preceding this protocol.  <a href="#a94cb5005a93c5318a99234f36c9259e5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_abstract_protocol.html">AbstractProtocol</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_protocol.html#ab7ecfd75e44450db380fc24694a478c6">next</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Protocol succeeding this protocol.  <a href="#ab7ecfd75e44450db380fc24694a478c6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_abstract_protocol.html#a01ec7a50fc120622da25ef754ef9051d">_hasPayload</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Is protocol typically followed by payload or another protocol.  <a href="#a01ec7a50fc120622da25ef754ef9051d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5458a3a111caf2de95b233fabd2cf87a"></a><!-- doxytag: member="AbstractProtocol::_cacheFlags" ref="a5458a3a111caf2de95b233fabd2cf87a" args="" -->
quint32&#160;</td><td class="memItemRight" valign="bottom"><b>_cacheFlags</b></td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5b0c6ffd2be050bb3b988dd7a4bb38e9"></a><!-- doxytag: member="AbstractProtocol::ComboProtocol" ref="a5b0c6ffd2be050bb3b988dd7a4bb38e9" args="" -->
class&#160;</td><td class="memItemRight" valign="bottom"><b>ComboProtocol</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aae91a2b14a2cdd4405a6703faabe82ff"></a><!-- doxytag: member="AbstractProtocol::ProtocolListIterator" ref="aae91a2b14a2cdd4405a6703faabe82ff" args="" -->
class&#160;</td><td class="memItemRight" valign="bottom"><b>ProtocolListIterator</b></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p><a class="el" href="class_abstract_protocol.html" title="AbstractProtocol is the base abstract class which provides the interface for all protocols.">AbstractProtocol</a> is the base abstract class which provides the interface for all protocols. </p>
<p>All protocols supported by Ostinato are derived from <a class="el" href="class_abstract_protocol.html" title="AbstractProtocol is the base abstract class which provides the interface for all protocols.">AbstractProtocol</a>. Apart from defining the interface for a protocol, it also provides sensible default implementations for methods so that the subclasses need not re-implement. It also provides convenience functions for subclasses to use such as methods to retrieve payload size, checksum etc.</p>
<p>A subclass typically needs to reimplement the following methods -</p>
<ul>
<li><a class="el" href="class_abstract_protocol.html#a88bb4dec958836f9ec65f32f797253d1" title="Returns the full name of the protocol.">name()</a></li>
<li><a class="el" href="class_abstract_protocol.html#add629f97f1e6633fc8ec6b936e06ca77" title="Returns the short name or abbreviation of the protocol.">shortName()</a></li>
<li><a class="el" href="class_abstract_protocol.html#a5f4b770b062f0cfd90ec9f93f8d737f8" title="Allocates and returns a new instance of the class.">createInstance()</a></li>
<li><a class="el" href="class_abstract_protocol.html#a11d85e6249098392eb2c29212613b880" title="Returns the protocol&#39;s field number as defined in message &#39;Protocol&#39;, enum &#39;k&#39; (file: protocol...">protocolNumber()</a></li>
<li><a class="el" href="class_abstract_protocol.html#ad632e0fc6fcd86a0fecefd6fa3cf2724" title="Copy the protocol&#39;s protobuf as an extension into the passed in protocol.">protoDataCopyInto()</a> [pure virtual]</li>
<li><a class="el" href="class_abstract_protocol.html#a124e67926605177d7787ae649ba57a99" title="Copy and update the protocol&#39;s protobuf member data variable from the passed in protocol.">protoDataCopyFrom()</a> [pure virtual]</li>
<li><a class="el" href="class_abstract_protocol.html#a5c26dc650b8480265ceaa8bfb6f30357" title="Returns the number of fields in the protocol (both Frame fields and Meta fields)">fieldCount()</a></li>
<li><a class="el" href="class_abstract_protocol.html#aa9dea7d27d100f8886f3abcad5220e0b" title="Returns the field flags for the passed in field index.">fieldFlags()</a></li>
<li><a class="el" href="class_abstract_protocol.html#a63aa72e9a3d7c666f75a5442a36b894b" title="Returns the requested field attribute data.">fieldData()</a></li>
<li><a class="el" href="class_abstract_protocol.html#ab0c6da690a523a49134944fb1d56b6ac" title="Sets the value of a field corresponding to index.">setFieldData()</a></li>
</ul>
<p>Depending on certain conditions, subclasses may need to reimplement the following additional methods -</p>
<ul>
<li><a class="el" href="class_abstract_protocol.html#abd1dad7fee4194e4da537f82f1a2a162" title="Returns the protocolIdType for the protocol.">protocolIdType()</a></li>
<li><a class="el" href="class_abstract_protocol.html#a09724ee80fa35bad5e00bf8581084bb7" title="Returns the protocol id of the protocol for the given type.">protocolId()</a></li>
<li><a class="el" href="class_abstract_protocol.html#a62f842e0d07c382e20d70b78ed39c21c" title="Returns the protocol&#39;s size in bytes.">protocolFrameSize()</a></li>
<li><a class="el" href="class_abstract_protocol.html#acf6eeb9f4db0848295b125906c92eea4" title="Returns true if the protocol varies its size at run-time, false otherwise.">isProtocolFrameSizeVariable()</a></li>
<li><a class="el" href="class_abstract_protocol.html#a527b6ca531b3489ef29d47bc4f38f361" title="Returns the minimum number of frames required for the protocol to vary its fields.">protocolFrameVariableCount()</a></li>
</ul>
<p>See the description of the methods for more information.</p>
<p>Most of the above methods just need some standard boilerplate code - the SampleProtocol implementation includes the boilerplate </p>
</div><hr/><h2>Member Enumeration Documentation</h2>
<a class="anchor" id="ad845fce434d744158360470faf446071"></a><!-- doxytag: member="AbstractProtocol::CacheFlag" ref="ad845fce434d744158360470faf446071" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_abstract_protocol.html#ad845fce434d744158360470faf446071">AbstractProtocol::CacheFlag</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Caching Control Flags. </p>

</div>
</div>
<a class="anchor" id="a3fa9027a98c6e78c97ea2b21d278a1ce"></a><!-- doxytag: member="AbstractProtocol::CksumScope" ref="a3fa9027a98c6e78c97ea2b21d278a1ce" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_abstract_protocol.html#a3fa9027a98c6e78c97ea2b21d278a1ce">AbstractProtocol::CksumScope</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Supported checksum scopes. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a3fa9027a98c6e78c97ea2b21d278a1ceaf73a5e1ed72ff2afbd51aadf636f2c4b"></a><!-- doxytag: member="CksumScopeAdjacentProtocol" ref="a3fa9027a98c6e78c97ea2b21d278a1ceaf73a5e1ed72ff2afbd51aadf636f2c4b" args="" -->CksumScopeAdjacentProtocol</em>&nbsp;</td><td>
<p>Cksum only the adjacent protocol. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a3fa9027a98c6e78c97ea2b21d278a1ceaaa680c3020e9d6ec42e3283cd326d6b2"></a><!-- doxytag: member="CksumScopeAllProtocols" ref="a3fa9027a98c6e78c97ea2b21d278a1ceaaa680c3020e9d6ec42e3283cd326d6b2" args="" -->CksumScopeAllProtocols</em>&nbsp;</td><td>
<p>Cksum over all the protocols. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a54c7dc4c12d9fc9032641166551f2b65"></a><!-- doxytag: member="AbstractProtocol::CksumType" ref="a54c7dc4c12d9fc9032641166551f2b65" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_abstract_protocol.html#a54c7dc4c12d9fc9032641166551f2b65">AbstractProtocol::CksumType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Supported checksum types. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a54c7dc4c12d9fc9032641166551f2b65ae9c2c223559327eda034dc7e3499948f"></a><!-- doxytag: member="CksumIp" ref="a54c7dc4c12d9fc9032641166551f2b65ae9c2c223559327eda034dc7e3499948f" args="" -->CksumIp</em>&nbsp;</td><td>
<p>Standard IP Checksum. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a54c7dc4c12d9fc9032641166551f2b65a69e3f4f4e9a5b5ae357380b8e0cb2d4f"></a><!-- doxytag: member="CksumIpPseudo" ref="a54c7dc4c12d9fc9032641166551f2b65a69e3f4f4e9a5b5ae357380b8e0cb2d4f" args="" -->CksumIpPseudo</em>&nbsp;</td><td>
<p>Standard checksum for Pseudo-IP header. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a54c7dc4c12d9fc9032641166551f2b65a1db5d75b3ca5342d57c78668de8b2c07"></a><!-- doxytag: member="CksumTcpUdp" ref="a54c7dc4c12d9fc9032641166551f2b65a1db5d75b3ca5342d57c78668de8b2c07" args="" -->CksumTcpUdp</em>&nbsp;</td><td>
<p>Standard TCP/UDP checksum including pseudo-IP. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a54c7dc4c12d9fc9032641166551f2b65a4d5ab2c30b009fbac93c3b1e4e36f8c9"></a><!-- doxytag: member="CksumMax" ref="a54c7dc4c12d9fc9032641166551f2b65a4d5ab2c30b009fbac93c3b1e4e36f8c9" args="" -->CksumMax</em>&nbsp;</td><td>
<p>Marker for number of cksum types. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a264223e35af983ba7016700b17f24b2c"></a><!-- doxytag: member="AbstractProtocol::FieldAttrib" ref="a264223e35af983ba7016700b17f24b2c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_abstract_protocol.html#a264223e35af983ba7016700b17f24b2c">AbstractProtocol::FieldAttrib</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Various attributes of a field. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a264223e35af983ba7016700b17f24b2ca6a6eabda81c9937845258bd6a87197af"></a><!-- doxytag: member="FieldName" ref="a264223e35af983ba7016700b17f24b2ca6a6eabda81c9937845258bd6a87197af" args="" -->FieldName</em>&nbsp;</td><td>
<p>name </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a264223e35af983ba7016700b17f24b2ca6f6cbe2c8b4bb7ba90f77bb71ab148df"></a><!-- doxytag: member="FieldValue" ref="a264223e35af983ba7016700b17f24b2ca6f6cbe2c8b4bb7ba90f77bb71ab148df" args="" -->FieldValue</em>&nbsp;</td><td>
<p>value in host byte order (user editable) </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a264223e35af983ba7016700b17f24b2ca39c3a7bfe08b218a6dd0b0c93752cf57"></a><!-- doxytag: member="FieldTextValue" ref="a264223e35af983ba7016700b17f24b2ca39c3a7bfe08b218a6dd0b0c93752cf57" args="" -->FieldTextValue</em>&nbsp;</td><td>
<p>value as text </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a264223e35af983ba7016700b17f24b2cabb3fc3111e7d887281728ccd95c0e876"></a><!-- doxytag: member="FieldFrameValue" ref="a264223e35af983ba7016700b17f24b2cabb3fc3111e7d887281728ccd95c0e876" args="" -->FieldFrameValue</em>&nbsp;</td><td>
<p>frame encoded value in network byte order </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a264223e35af983ba7016700b17f24b2cabf037461e1abed7603d311f701a560d8"></a><!-- doxytag: member="FieldBitSize" ref="a264223e35af983ba7016700b17f24b2cabf037461e1abed7603d311f701a560d8" args="" -->FieldBitSize</em>&nbsp;</td><td>
<p>size in bits </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a71a018a1a39da3fd0b22f348e21c85e8"></a><!-- doxytag: member="AbstractProtocol::FieldFlag" ref="a71a018a1a39da3fd0b22f348e21c85e8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_abstract_protocol.html#a71a018a1a39da3fd0b22f348e21c85e8">AbstractProtocol::FieldFlag</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Properties of a field, can be OR'd. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a71a018a1a39da3fd0b22f348e21c85e8a975bb1cfe826bcf6044b7432f8b4dee4"></a><!-- doxytag: member="FrameField" ref="a71a018a1a39da3fd0b22f348e21c85e8a975bb1cfe826bcf6044b7432f8b4dee4" args="" -->FrameField</em>&nbsp;</td><td>
<p>field appears in frame content </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a71a018a1a39da3fd0b22f348e21c85e8a4674267e0b1ca900b107823a094c44f2"></a><!-- doxytag: member="MetaField" ref="a71a018a1a39da3fd0b22f348e21c85e8a4674267e0b1ca900b107823a094c44f2" args="" -->MetaField</em>&nbsp;</td><td>
<p>field does not appear in frame, is meta data </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a71a018a1a39da3fd0b22f348e21c85e8ac5407d0629943e055651b900df2b8cfa"></a><!-- doxytag: member="CksumField" ref="a71a018a1a39da3fd0b22f348e21c85e8ac5407d0629943e055651b900df2b8cfa" args="" -->CksumField</em>&nbsp;</td><td>
<p>field is a checksum and appears in frame content </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<a class="anchor" id="a94af7be261834da225cdda75223a600f"></a><!-- doxytag: member="AbstractProtocol::ProtocolIdType" ref="a94af7be261834da225cdda75223a600f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_abstract_protocol.html#a94af7be261834da225cdda75223a600f">AbstractProtocol::ProtocolIdType</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Supported Protocol Id types. </p>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a94af7be261834da225cdda75223a600fa7caf04230689c991aea6ea98dd6cb44f"></a><!-- doxytag: member="ProtocolIdNone" ref="a94af7be261834da225cdda75223a600fa7caf04230689c991aea6ea98dd6cb44f" args="" -->ProtocolIdNone</em>&nbsp;</td><td>
<p>Marker representing non-existent protocol id. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a94af7be261834da225cdda75223a600fa018f343eea81889b34ce37be982a0949"></a><!-- doxytag: member="ProtocolIdLlc" ref="a94af7be261834da225cdda75223a600fa018f343eea81889b34ce37be982a0949" args="" -->ProtocolIdLlc</em>&nbsp;</td><td>
<p>LLC (802.2) </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a94af7be261834da225cdda75223a600fab4be19b14834dbc2106d2f69daad8156"></a><!-- doxytag: member="ProtocolIdEth" ref="a94af7be261834da225cdda75223a600fab4be19b14834dbc2106d2f69daad8156" args="" -->ProtocolIdEth</em>&nbsp;</td><td>
<p>Ethernet II. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a94af7be261834da225cdda75223a600fac232e06fa03ade8b73b6f805fbf4e594"></a><!-- doxytag: member="ProtocolIdIp" ref="a94af7be261834da225cdda75223a600fac232e06fa03ade8b73b6f805fbf4e594" args="" -->ProtocolIdIp</em>&nbsp;</td><td>
<p>IP. </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a94af7be261834da225cdda75223a600fa6ccc40767925f33be3c4ba94503d4819"></a><!-- doxytag: member="ProtocolIdTcpUdp" ref="a94af7be261834da225cdda75223a600fa6ccc40767925f33be3c4ba94503d4819" args="" -->ProtocolIdTcpUdp</em>&nbsp;</td><td>
<p>TCP/UDP Port Number. </p>
</td></tr>
</table>
</dd>
</dl>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a8ef6adaa06c7fc87b5b029f685030848"></a><!-- doxytag: member="AbstractProtocol::AbstractProtocol" ref="a8ef6adaa06c7fc87b5b029f685030848" args="(StreamBase *stream, AbstractProtocol *parent=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AbstractProtocol::AbstractProtocol </td>
          <td>(</td>
          <td class="paramtype">StreamBase *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_abstract_protocol.html">AbstractProtocol</a> *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Constructs an abstract protocol for the given stream and parent. </p>
<p>parent is typically NULL except for protocols which are part of a ComboProtocol </p>

</div>
</div>
<a class="anchor" id="a7ccbf35c6141e0d6aa136e4100c4d39b"></a><!-- doxytag: member="AbstractProtocol::~AbstractProtocol" ref="a7ccbf35c6141e0d6aa136e4100c4d39b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AbstractProtocol::~AbstractProtocol </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Destroys the abstract protocol. </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a020c049c35328d847606a571455cc298"></a><!-- doxytag: member="AbstractProtocol::appendVariableField" ref="a020c049c35328d847606a571455cc298" args="(const OstProto::VariableField &amp;vf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AbstractProtocol::appendVariableField </td>
          <td>(</td>
          <td class="paramtype">const OstProto::VariableField &amp;&#160;</td>
          <td class="paramname"><em>vf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Appends a variableField to the protocol. </p>

</div>
</div>
<a class="anchor" id="aa4654b842f274e0daee280684adef2c1"></a><!-- doxytag: member="AbstractProtocol::commonProtoDataCopyFrom" ref="aa4654b842f274e0daee280684adef2c1" args="(const OstProto::Protocol &amp;protocol)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AbstractProtocol::commonProtoDataCopyFrom </td>
          <td>(</td>
          <td class="paramtype">const OstProto::Protocol &amp;&#160;</td>
          <td class="paramname"><em>protocol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies the common data (not specific to individual protocols) from the passed in param protocol protobuf into the member protobuf data. </p>
<p>The individual protocol specific protobuf data is copied using <a class="el" href="class_abstract_protocol.html#a124e67926605177d7787ae649ba57a99" title="Copy and update the protocol&#39;s protobuf member data variable from the passed in protocol.">protoDataCopyFrom()</a> </p>

</div>
</div>
<a class="anchor" id="a818b999e0fe20710b62e100ecad124f3"></a><!-- doxytag: member="AbstractProtocol::commonProtoDataCopyInto" ref="a818b999e0fe20710b62e100ecad124f3" args="(OstProto::Protocol &amp;protocol) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AbstractProtocol::commonProtoDataCopyInto </td>
          <td>(</td>
          <td class="paramtype">OstProto::Protocol &amp;&#160;</td>
          <td class="paramname"><em>protocol</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copies the common data (not specific to individual protocols) in the protocol member protobuf data into the passed in protocol parameter. </p>
<p>The individual protocol specific protobuf data is copied using <a class="el" href="class_abstract_protocol.html#ad632e0fc6fcd86a0fecefd6fa3cf2724" title="Copy the protocol&#39;s protobuf as an extension into the passed in protocol.">protoDataCopyInto()</a> </p>

</div>
</div>
<a class="anchor" id="a5f4b770b062f0cfd90ec9f93f8d737f8"></a><!-- doxytag: member="AbstractProtocol::createInstance" ref="a5f4b770b062f0cfd90ec9f93f8d737f8" args="(StreamBase *stream, AbstractProtocol *parent=0)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_abstract_protocol.html">AbstractProtocol</a> * AbstractProtocol::createInstance </td>
          <td>(</td>
          <td class="paramtype">StreamBase *&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_abstract_protocol.html">AbstractProtocol</a> *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocates and returns a new instance of the class. </p>
<p>Caller is responsible for freeing up after use. Subclasses MUST implement this function </p>

</div>
</div>
<a class="anchor" id="a5c26dc650b8480265ceaa8bfb6f30357"></a><!-- doxytag: member="AbstractProtocol::fieldCount" ref="a5c26dc650b8480265ceaa8bfb6f30357" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AbstractProtocol::fieldCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the number of fields in the protocol (both Frame fields and Meta fields) </p>
<p>The default implementation returns zero. Subclasses MUST implement this function. </p>

</div>
</div>
<a class="anchor" id="a63aa72e9a3d7c666f75a5442a36b894b"></a><!-- doxytag: member="AbstractProtocol::fieldData" ref="a63aa72e9a3d7c666f75a5442a36b894b" args="(int index, FieldAttrib attrib, int streamIndex=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QVariant AbstractProtocol::fieldData </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_abstract_protocol.html#a264223e35af983ba7016700b17f24b2c">FieldAttrib</a>&#160;</td>
          <td class="paramname"><em>attrib</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>streamIndex</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the requested field attribute data. </p>
<p>Protocols which have meta fields that vary a frame field across streams may use the streamIndex to return the appropriate field value <br/>
 Some field attributes e.g. FieldName may be invariant across streams<br/>
 The FieldTextValue attribute may include additional information about the field's value e.g. a checksum field may include "(correct)" or "(incorrect)" alongwith the actual checksum value. <br/>
</p>
<p>The default implementation returns a empty string for FieldName and FieldTextValue; empty byte array of size 0 for FieldFrameValue; 0 for FieldValue; subclasses are expected to return meaning values for all these attributes. The only exception is the 'FieldBitSize' attribute - the default implementation takes the (byte) size of FieldFrameValue, multiplies it with 8 and returns the result - this can be used by subclasses for fields which are an integral multiple of bytes; for fields whose size are a non-integral multiple of bytes or smaller than a byte, subclasses should return the correct value. Also for fields which represent checksums, subclasses should return a value for FieldBitSize - even if it is an integral multiple of bytes.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>If a subclass uses any of the below functions to derive FieldFrameValue, the subclass should handle and return a value for FieldBitSize to prevent endless recursion -<ul>
<li><a class="el" href="class_abstract_protocol.html#af5f206edd6050e10321756889086cc19" title="Returns the checksum (of the requested type) of the protocol&#39;s contents.">protocolFrameCksum()</a></li>
<li><a class="el" href="class_abstract_protocol.html#af0826fd6957b30bdc1b0af5e9ac6987d" title="Returns the size of the payload in bytes.">protocolFramePayloadSize()</a> </li>
</ul>
</dd></dl>

</div>
</div>
<a class="anchor" id="aa9dea7d27d100f8886f3abcad5220e0b"></a><!-- doxytag: member="AbstractProtocol::fieldFlags" ref="aa9dea7d27d100f8886f3abcad5220e0b" args="(int index) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">AbstractProtocol::FieldFlags AbstractProtocol::fieldFlags </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the field flags for the passed in field index. </p>
<p>The default implementation assumes all fields to be frame fields and returns 'FrameField'. Subclasses must reimplement this method if they have any meta fields or checksum fields. See the SampleProtocol for an example. </p>

</div>
</div>
<a class="anchor" id="a1a7491fe014db3307b7e443fcb23d3f8"></a><!-- doxytag: member="AbstractProtocol::fieldFrameBitOffset" ref="a1a7491fe014db3307b7e443fcb23d3f8" args="(int index, int streamIndex=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AbstractProtocol::fieldFrameBitOffset </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>streamIndex</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the bit offset where the specified field starts within the <a class="el" href="class_abstract_protocol.html#a71c64ddfb9797d2e567013f3dcf93c73" title="Returns a byte array encoding the protocol (and its fields) which can be inserted into the stream&#39;s f...">protocolFrameValue()</a> </p>

</div>
</div>
<a class="anchor" id="acac964c423928703a0da8c21fa6dfe50"></a><!-- doxytag: member="AbstractProtocol::frameFieldCount" ref="acac964c423928703a0da8c21fa6dfe50" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AbstractProtocol::frameFieldCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the number of frame fields. </p>
<p>The default implementation counts and returns the number of fields for which the FrameField flag is set<br/>
 The default implementation caches the count on its first invocation and subsequently returns the cached count</p>
<p>Subclasses which export different sets of fields based on a opcode/type (e.g. icmp) should re-implement this function </p>

</div>
</div>
<a class="anchor" id="adb3d714eae41034500c70663a8792790"></a><!-- doxytag: member="AbstractProtocol::isProtocolFramePayloadSizeVariable" ref="adb3d714eae41034500c70663a8792790" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AbstractProtocol::isProtocolFramePayloadSizeVariable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if the payload size for a protocol varies at run-time, false otherwise. </p>
<p>This is useful for subclasses which have fields dependent on payload size (e.g. UDP has a checksum field that varies if the payload varies) </p>

</div>
</div>
<a class="anchor" id="a507683641d443b62e36998b1bd4d3533"></a><!-- doxytag: member="AbstractProtocol::isProtocolFramePayloadValueVariable" ref="a507683641d443b62e36998b1bd4d3533" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AbstractProtocol::isProtocolFramePayloadValueVariable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if the payload content for a protocol varies at run-time, false otherwise. </p>
<p>This is useful for subclasses which have fields dependent on payload content (e.g. UDP has a checksum field that varies if the payload varies) </p>

</div>
</div>
<a class="anchor" id="acf6eeb9f4db0848295b125906c92eea4"></a><!-- doxytag: member="AbstractProtocol::isProtocolFrameSizeVariable" ref="acf6eeb9f4db0848295b125906c92eea4" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AbstractProtocol::isProtocolFrameSizeVariable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if the protocol varies its size at run-time, false otherwise. </p>
<p>The default implmentation returns false. A subclass should reimplement if it varies its size at run-time e.g. a Payload protocol for a stream with incrementing/decrementing frame lengths </p>

</div>
</div>
<a class="anchor" id="aec6223a44cff630869ae4535c00ae11f"></a><!-- doxytag: member="AbstractProtocol::isProtocolFrameValueVariable" ref="aec6223a44cff630869ae4535c00ae11f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AbstractProtocol::isProtocolFrameValueVariable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if the protocol varies one or more of its fields at run-time, false otherwise. </p>

</div>
</div>
<a class="anchor" id="a1720f5fae0e7c90ba52d0d4cb04c80fe"></a><!-- doxytag: member="AbstractProtocol::metaFieldCount" ref="a1720f5fae0e7c90ba52d0d4cb04c80fe" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AbstractProtocol::metaFieldCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the number of meta fields. </p>
<p>The default implementation counts and returns the number of fields for which the MetaField flag is set<br/>
 The default implementation caches the count on its first invocation and subsequently returns the cached count </p>

</div>
</div>
<a class="anchor" id="a8afe28a07915431c59c57769ef037cf3"></a><!-- doxytag: member="AbstractProtocol::mutableVariableField" ref="a8afe28a07915431c59c57769ef037cf3" args="(int index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OstProto::VariableField * AbstractProtocol::mutableVariableField </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the variableField at the specified index as a mutable pointer. </p>
<p>Changes made via the pointer will be reflected in the protocol </p>

</div>
</div>
<a class="anchor" id="a88bb4dec958836f9ec65f32f797253d1"></a><!-- doxytag: member="AbstractProtocol::name" ref="a88bb4dec958836f9ec65f32f797253d1" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QString AbstractProtocol::name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the full name of the protocol. </p>
<p>The default implementation returns a null string </p>

</div>
</div>
<a class="anchor" id="a8115d60319fe23b71b6d4de46d800bef"></a><!-- doxytag: member="AbstractProtocol::payloadProtocolId" ref="a8115d60319fe23b71b6d4de46d800bef" args="(ProtocolIdType type) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">quint32 AbstractProtocol::payloadProtocolId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_abstract_protocol.html#a94af7be261834da225cdda75223a600f">ProtocolIdType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the protocol id of the payload protocol (the protocol that immediately follows the current one) </p>
<p>A subclass which has a protocol id field, can use this to retrieve the appropriate value </p>

</div>
</div>
<a class="anchor" id="af5f206edd6050e10321756889086cc19"></a><!-- doxytag: member="AbstractProtocol::protocolFrameCksum" ref="af5f206edd6050e10321756889086cc19" args="(int streamIndex=0, CksumType cksumType=CksumIp) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">quint32 AbstractProtocol::protocolFrameCksum </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>streamIndex</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_abstract_protocol.html#a54c7dc4c12d9fc9032641166551f2b65">CksumType</a>&#160;</td>
          <td class="paramname"><em>cksumType</em> = <code>CksumIp</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the checksum (of the requested type) of the protocol's contents. </p>
<p>Useful for protocols which have a checksum field</p>
<dl class="note"><dt><b>Note:</b></dt><dd>If a subclass uses <a class="el" href="class_abstract_protocol.html#af5f206edd6050e10321756889086cc19" title="Returns the checksum (of the requested type) of the protocol&#39;s contents.">protocolFrameCksum()</a> from within <a class="el" href="class_abstract_protocol.html#a63aa72e9a3d7c666f75a5442a36b894b" title="Returns the requested field attribute data.">fieldData()</a> to derive a cksum field, it MUST handle and return the 'FieldBitSize' attribute also for that particular field instead of using the default <a class="el" href="class_abstract_protocol.html" title="AbstractProtocol is the base abstract class which provides the interface for all protocols.">AbstractProtocol</a> implementation for 'FieldBitSize' - this is required to prevent infinite recursion </dd></dl>

</div>
</div>
<a class="anchor" id="ac0f92f797429fa74deb4a451ccd18f01"></a><!-- doxytag: member="AbstractProtocol::protocolFrameHeaderCksum" ref="ac0f92f797429fa74deb4a451ccd18f01" args="(int streamIndex=0, CksumType cksumType=CksumIp, CksumScope cksumScope=CksumScopeAdjacentProtocol) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">quint32 AbstractProtocol::protocolFrameHeaderCksum </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>streamIndex</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_abstract_protocol.html#a54c7dc4c12d9fc9032641166551f2b65">CksumType</a>&#160;</td>
          <td class="paramname"><em>cksumType</em> = <code>CksumIp</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_abstract_protocol.html#a3fa9027a98c6e78c97ea2b21d278a1ce">CksumScope</a>&#160;</td>
          <td class="paramname"><em>cksumScope</em> = <code>CksumScopeAdjacentProtocol</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the checksum of the requested type for the protocol's header. </p>
<p>This is useful for subclasses which needs the header's checksum e.g. TCP/UDP require a "Pseudo-IP" checksum. The checksum is limited to the specified scope.</p>
<p>Currently the default implementation supports only type CksumIpPseudo</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The default value for cksumScope is different for <a class="el" href="class_abstract_protocol.html#ac0f92f797429fa74deb4a451ccd18f01" title="Returns the checksum of the requested type for the protocol&#39;s header.">protocolFrameHeaderCksum()</a> and <a class="el" href="class_abstract_protocol.html#aa3294a383d53b9d963d885eb53558d62" title="Returns the checksum of the requested type for the protocol&#39;s payload.">protocolFramePayloadCksum()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aff15d2fdc6df8db5bc5b13fbacb57675"></a><!-- doxytag: member="AbstractProtocol::protocolFrameOffset" ref="aff15d2fdc6df8db5bc5b13fbacb57675" args="(int streamIndex=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AbstractProtocol::protocolFrameOffset </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>streamIndex</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the byte offset in the packet where the protocol starts. </p>
<p>This method is useful only for "padding" protocols i.e. protocols which fill up the remaining space for the user defined packet size e.g. the PatternPayload protocol </p>

</div>
</div>
<a class="anchor" id="aa3294a383d53b9d963d885eb53558d62"></a><!-- doxytag: member="AbstractProtocol::protocolFramePayloadCksum" ref="aa3294a383d53b9d963d885eb53558d62" args="(int streamIndex=0, CksumType cksumType=CksumIp, CksumScope cksumScope=CksumScopeAllProtocols) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">quint32 AbstractProtocol::protocolFramePayloadCksum </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>streamIndex</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_abstract_protocol.html#a54c7dc4c12d9fc9032641166551f2b65">CksumType</a>&#160;</td>
          <td class="paramname"><em>cksumType</em> = <code>CksumIp</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_abstract_protocol.html#a3fa9027a98c6e78c97ea2b21d278a1ce">CksumScope</a>&#160;</td>
          <td class="paramname"><em>cksumScope</em> = <code>CksumScopeAllProtocols</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the checksum of the requested type for the protocol's payload. </p>
<p>This is useful for subclasses which needs the payload's checksum e.g. TCP/UDP require a IP checksum of the payload (to be combined with other checksums to derive the final checksum). The checksum is limited to the specified scope.</p>
<p>Currently the default implementation supports only type CksumIp</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The default value for cksumScope is different for <a class="el" href="class_abstract_protocol.html#ac0f92f797429fa74deb4a451ccd18f01" title="Returns the checksum of the requested type for the protocol&#39;s header.">protocolFrameHeaderCksum()</a> and <a class="el" href="class_abstract_protocol.html#aa3294a383d53b9d963d885eb53558d62" title="Returns the checksum of the requested type for the protocol&#39;s payload.">protocolFramePayloadCksum()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="af0826fd6957b30bdc1b0af5e9ac6987d"></a><!-- doxytag: member="AbstractProtocol::protocolFramePayloadSize" ref="af0826fd6957b30bdc1b0af5e9ac6987d" args="(int streamIndex=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AbstractProtocol::protocolFramePayloadSize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>streamIndex</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the size of the payload in bytes. </p>
<p>The payload includes all protocols subsequent to the current</p>
<p>This method is useful for protocols which need to fill in a payload size field </p>

</div>
</div>
<a class="anchor" id="ad3cd83ac4774ef40e90a3db4eea44bcd"></a><!-- doxytag: member="AbstractProtocol::protocolFramePayloadVariableCount" ref="ad3cd83ac4774ef40e90a3db4eea44bcd" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AbstractProtocol::protocolFramePayloadVariableCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if the payload size for a protocol varies at run-time, false otherwise. </p>
<p>This is useful for subclasses which have fields dependent on payload size (e.g. UDP has a checksum field that varies if the payload varies) </p>

</div>
</div>
<a class="anchor" id="a62f842e0d07c382e20d70b78ed39c21c"></a><!-- doxytag: member="AbstractProtocol::protocolFrameSize" ref="a62f842e0d07c382e20d70b78ed39c21c" args="(int streamIndex=0) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AbstractProtocol::protocolFrameSize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>streamIndex</em> = <code>0</code></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the protocol's size in bytes. </p>
<p>The default implementation sums up the individual field bit sizes and returns it. The default implementation calculates the caches the size on the first invocation and subsequently returns the cached size.</p>
<p>If the subclass protocol has a varying protocol size, it MUST reimplement this method, otherwise the default implementation is sufficient. </p>

</div>
</div>
<a class="anchor" id="a71c64ddfb9797d2e567013f3dcf93c73"></a><!-- doxytag: member="AbstractProtocol::protocolFrameValue" ref="a71c64ddfb9797d2e567013f3dcf93c73" args="(int streamIndex=0, bool forCksum=false) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QByteArray AbstractProtocol::protocolFrameValue </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>streamIndex</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>forCksum</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns a byte array encoding the protocol (and its fields) which can be inserted into the stream's frame. </p>
<p>The default implementation forms and returns an ordered concatenation of the FrameValue of all the 'frame' fields of the protocol also taking care of fields which are not an integral number of bytes<br/>
 </p>

</div>
</div>
<a class="anchor" id="a527b6ca531b3489ef29d47bc4f38f361"></a><!-- doxytag: member="AbstractProtocol::protocolFrameVariableCount" ref="a527b6ca531b3489ef29d47bc4f38f361" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AbstractProtocol::protocolFrameVariableCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the minimum number of frames required for the protocol to vary its fields. </p>
<p>This is the lowest common multiple (LCM) of the counts of all the varying fields in the protocol. Use the AbstractProtocol::lcm() static utility function to calculate the LCM.</p>
<p>The default implementation returns the LCM of all variableFields A subclass should reimplement if it has varying fields e.g. an IP protocol that increments/decrements the IP address with every packet.<br/>
 Subclasses should call the base class method to retreive the count and do a LCM with the subclass' own varying fields </p>

</div>
</div>
<a class="anchor" id="acb1603f1b707cc28b7fb2ad4642eab01"></a><!-- doxytag: member="AbstractProtocol::protocolHasPayload" ref="acb1603f1b707cc28b7fb2ad4642eab01" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AbstractProtocol::protocolHasPayload </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns true if the protocol typically contains a payload or other protocols following it e.g. </p>
<p>TCP, UDP have payloads, while ARP, IGMP do not</p>
<p>The default implementation returns true. If a subclass does not have a payload, it should set the _hasPayload data member to false </p>

</div>
</div>
<a class="anchor" id="a09724ee80fa35bad5e00bf8581084bb7"></a><!-- doxytag: member="AbstractProtocol::protocolId" ref="a09724ee80fa35bad5e00bf8581084bb7" args="(ProtocolIdType type) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">quint32 AbstractProtocol::protocolId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_abstract_protocol.html#a94af7be261834da225cdda75223a600f">ProtocolIdType</a>&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the protocol id of the protocol for the given type. </p>
<p>The default implementation returns 0. If a subclass represents a protocol which has a particular protocol id, it should return the appropriate value. If a protocol does not have an id for the given type, it should defer to the base class. e.g. IGMP will return 2 for ProtocolIdIp, and defer to the base class for the remaining ProtocolIdTypes; IP will return 0x800 for ProtocolIdEth type, 0x060603 for ProtocolIdLlc and 0x04 for ProtocolIdIp etc. </p>

</div>
</div>
<a class="anchor" id="abd1dad7fee4194e4da537f82f1a2a162"></a><!-- doxytag: member="AbstractProtocol::protocolIdType" ref="abd1dad7fee4194e4da537f82f1a2a162" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_abstract_protocol.html#a94af7be261834da225cdda75223a600f">AbstractProtocol::ProtocolIdType</a> AbstractProtocol::protocolIdType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the protocolIdType for the protocol. </p>
<p>The default implementation returns ProtocolIdNone. If a subclass has a protocolId field it should return the appropriate value e.g. IP protocol will return ProtocolIdIp, Ethernet will return ProtocolIdEth etc. </p>

</div>
</div>
<a class="anchor" id="a11d85e6249098392eb2c29212613b880"></a><!-- doxytag: member="AbstractProtocol::protocolNumber" ref="a11d85e6249098392eb2c29212613b880" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">quint32 AbstractProtocol::protocolNumber </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the protocol's field number as defined in message 'Protocol', enum 'k' (<a href="file:">file:</a> protocol.proto) </p>
<p>Subclasses MUST implement this function</p>

</div>
</div>
<a class="anchor" id="a124e67926605177d7787ae649ba57a99"></a><!-- doxytag: member="AbstractProtocol::protoDataCopyFrom" ref="a124e67926605177d7787ae649ba57a99" args="(const OstProto::Protocol &amp;protocol)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AbstractProtocol::protoDataCopyFrom </td>
          <td>(</td>
          <td class="paramtype">const OstProto::Protocol &amp;&#160;</td>
          <td class="paramname"><em>protocol</em></td><td>)</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy and update the protocol's protobuf member data variable from the passed in protocol. </p>
<p>In the base class this is a pure virtual function. Subclasses MUST implement this function. See the SampleProtocol for an example </p>

</div>
</div>
<a class="anchor" id="ad632e0fc6fcd86a0fecefd6fa3cf2724"></a><!-- doxytag: member="AbstractProtocol::protoDataCopyInto" ref="ad632e0fc6fcd86a0fecefd6fa3cf2724" args="(OstProto::Protocol &amp;protocol) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AbstractProtocol::protoDataCopyInto </td>
          <td>(</td>
          <td class="paramtype">OstProto::Protocol &amp;&#160;</td>
          <td class="paramname"><em>protocol</em></td><td>)</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Copy the protocol's protobuf as an extension into the passed in protocol. </p>
<p>In the base class this is a pure virtual function. Subclasses MUST implement this function. See the SampleProtocol for an example </p>

</div>
</div>
<a class="anchor" id="a47c19d80bfeb03af263fd9b5db3bd56a"></a><!-- doxytag: member="AbstractProtocol::removeVariableField" ref="a47c19d80bfeb03af263fd9b5db3bd56a" args="(int index)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void AbstractProtocol::removeVariableField </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes the variableField from the protocol at the specified index. </p>

</div>
</div>
<a class="anchor" id="ab0c6da690a523a49134944fb1d56b6ac"></a><!-- doxytag: member="AbstractProtocol::setFieldData" ref="ab0c6da690a523a49134944fb1d56b6ac" args="(int index, const QVariant &amp;value, FieldAttrib attrib=FieldValue)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool AbstractProtocol::setFieldData </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const QVariant &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_abstract_protocol.html#a264223e35af983ba7016700b17f24b2c">FieldAttrib</a>&#160;</td>
          <td class="paramname"><em>attrib</em> = <code>FieldValue</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets the value of a field corresponding to index. </p>
<p>This method is called by the GUI code to store a user specified value into the protocol's protoBuf. Currently this method is called with FieldAttrib = FieldValue only.</p>
<p>Returns true if field is successfully set, false otherwise. The default implementation always returns false. Subclasses should reimplement this method. See SampleProtocol for an example. </p>

</div>
</div>
<a class="anchor" id="add629f97f1e6633fc8ec6b936e06ca77"></a><!-- doxytag: member="AbstractProtocol::shortName" ref="add629f97f1e6633fc8ec6b936e06ca77" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">QString AbstractProtocol::shortName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const<code> [virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the short name or abbreviation of the protocol. </p>
<p>The default implementation forms and returns an abbreviation composed of all the upper case chars in <a class="el" href="class_abstract_protocol.html#a88bb4dec958836f9ec65f32f797253d1" title="Returns the full name of the protocol.">name()</a> <br/>
 The default implementation caches the abbreviation on its first invocation and subsequently returns the cached abbreviation </p>

</div>
</div>
<a class="anchor" id="ae38a631ad22df35e3fcb8093d58dc0fa"></a><!-- doxytag: member="AbstractProtocol::variableField" ref="ae38a631ad22df35e3fcb8093d58dc0fa" args="(int index) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const OstProto::VariableField &amp; AbstractProtocol::variableField </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the variableField at the specified index as a constant Reference i.e. </p>
<p>read-only </p>

</div>
</div>
<a class="anchor" id="ae91b83c11b74182365a51e8736066aaa"></a><!-- doxytag: member="AbstractProtocol::variableFieldCount" ref="ae91b83c11b74182365a51e8736066aaa" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int AbstractProtocol::variableFieldCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the count of variableFields in the protocol. </p>

</div>
</div>
<hr/><h2>Member Data Documentation</h2>
<a class="anchor" id="a01ec7a50fc120622da25ef754ef9051d"></a><!-- doxytag: member="AbstractProtocol::_hasPayload" ref="a01ec7a50fc120622da25ef754ef9051d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_abstract_protocol.html#a01ec7a50fc120622da25ef754ef9051d">AbstractProtocol::_hasPayload</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Is protocol typically followed by payload or another protocol. </p>

</div>
</div>
<a class="anchor" id="a64a39e56273fea09038b4f4e2e9288bb"></a><!-- doxytag: member="AbstractProtocol::mpStream" ref="a64a39e56273fea09038b4f4e2e9288bb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">StreamBase* <a class="el" href="class_abstract_protocol.html#a64a39e56273fea09038b4f4e2e9288bb">AbstractProtocol::mpStream</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Stream that this protocol belongs to. </p>

</div>
</div>
<a class="anchor" id="ab7ecfd75e44450db380fc24694a478c6"></a><!-- doxytag: member="AbstractProtocol::next" ref="ab7ecfd75e44450db380fc24694a478c6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_abstract_protocol.html">AbstractProtocol</a>* <a class="el" href="class_abstract_protocol.html#ab7ecfd75e44450db380fc24694a478c6">AbstractProtocol::next</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Protocol succeeding this protocol. </p>

</div>
</div>
<a class="anchor" id="a0461f1cdeb9bb4bc85ad7e26daf0d600"></a><!-- doxytag: member="AbstractProtocol::parent" ref="a0461f1cdeb9bb4bc85ad7e26daf0d600" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_abstract_protocol.html">AbstractProtocol</a>* <a class="el" href="class_abstract_protocol.html#a0461f1cdeb9bb4bc85ad7e26daf0d600">AbstractProtocol::parent</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Parent protocol, if any. </p>

</div>
</div>
<a class="anchor" id="a94cb5005a93c5318a99234f36c9259e5"></a><!-- doxytag: member="AbstractProtocol::prev" ref="a94cb5005a93c5318a99234f36c9259e5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_abstract_protocol.html">AbstractProtocol</a>* <a class="el" href="class_abstract_protocol.html#a94cb5005a93c5318a99234f36c9259e5">AbstractProtocol::prev</a><code> [protected]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Protocol preceding this protocol. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>common/abstractprotocol.h</li>
<li>common/abstractprotocol.cpp</li>
</ul>
</div>


<hr class="footer"/><address class="footer"><small>
Generated on Tue Jun 2 2015 18:40:09 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.5.1
</small></address>

</body>
</html>
